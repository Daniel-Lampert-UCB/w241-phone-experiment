---
title: "R Notebook"
output: pdf_document
---

```{r}
library('data.table')
library('readr')
library('ggplot2')
library('readxl')
library('tidyverse')
library('sandwich')
library('lmtest')
```
# w241 Final Project: Clean Data and Basic Analysis

1. Read in data
```{r}
# read in data files
treatment_initial <- read_excel('groupA_initial.xlsx')
control_initial <- read_excel("groupB_initial.xlsx")
treatment_final <- read_excel('groupA_final.xlsx')
control_final <- read_excel("groupB_final.xlsx")
```



2. Functions to clean data
```{r}
# dropping and renaming columns

clean_initial_data <- function(data, treatment = FALSE) {
  
  # dropping first, extra row
  names(data) <- as.matrix(data[1, ])
  data <- data[-1, ]
  data[] <- lapply(data, function(x) type.convert(as.character(x)))
  
  # dropping and renaming columns for CONTROL GROUP
  if (treatment == FALSE) {
    data <- data[,-c(1:2)]
    data <- data[,-c(10:19)]
    data <- data[,-c(11)]
    data <- data.table(data)
    new <- c('date', 'first_name', 'last_name', 'age', 'country', 'social_apps', 'iphone', 'screen_time_rep', 'screen_time_on', 'screen_time_avg_initial')
    setnames(data,colnames(data),new)}
  
  # dropping and renaming columns for TREATMENT GROUP
  else {
    # dropping columns
    data <- data[,-c(1:7)]
    data<- data[,-c(2:10)]
    data <- data[,-c(10:19)]
    data <- data[,-c(12)]
    data <- data.table(data)
    new <- c('date', 'first_name', 'last_name', 'age', 'country', 'social_apps', 'iphone', 'greyscale', 'screen_time_rep', 'screen_time_on', 'screen_time_avg_initial')
    setnames(data,colnames(data),new)
  }
  
  # get rid of rows with empty values for name (indicates a faulty response)
  complete_vec <- complete.cases(data[, 'first_name'])
  data <- data[complete_vec,]
  
  # makes iphone column binary (iphone = 1, android = 0)
  data$iphone <- as.numeric(data$iphone == 'IPhone')
  
  # standardizing 'United States' label
  data$country <- ifelse((data$country == 'Mexico')|(data$country == 'MX')|(data$country == 'Mx')|(data$country == 'mexico')|(data$country == 'MÃ©xico'),             'Mexico', 'United States' )
  # convert date to readable type
  data$date <- as.Date(data$date, origin = "1899-12-30")
  
  # create a variable to indicate which group (first cohort or second) based on date
  data[,first_group := (as.numeric(as.Date(data$date, origin = "1899-12-30") < "2021-03-23"))]
  
  return(data)
}
```

```{r}
# dropping and renaming columns 

clean_final_data <- function(data, treatment = FALSE) {
  
  # dropping first, extra row
  names(data) <- as.matrix(data[1, ])
  data <- data[-1, ]
  data[] <- lapply(data, function(x) type.convert(as.character(x)))
  
  # dropping columns
  data <- data[,-c(1:7)]
  data <- data[,-c(2:10)]
  data <-data[,-c(5:28)]
  
  # dropping and renaming columns for CONTROL GROUP
  if (treatment == FALSE) {
    data <- data[,-c(8)]
    data <- data.table(data)
    new <- c('date', 'first_name', 'last_name', 'iphone', 'screen_time_1', 'screen_time_2', 'screen_time_3')
    setnames(data,colnames(data),new)}
  
  # dropping and renaming columns for TREATMENT GROUP
  else {
    # dropping columns
    data <- data.table(data)
    new <- c('date', 'first_name', 'last_name', 'iphone', 'screen_time_1', 'screen_time_2', 'screen_time_3')
    setnames(data,colnames(data),new)
  }
  
  # get rid of rows with empty values for name (indicates a faulty response)
  complete_vec <- complete.cases(data[, 'first_name'])
  data <- data[complete_vec,]
  
  # makes iphone column binary (iphone = 1, android = 0)
  data$iphone <- as.numeric(data$iphone == 'IPhone')
  
  # averages screen time 
  data[, screen_time_avg_final := (rowMeans(data[,c('screen_time_1', 'screen_time_2', 'screen_time_3')]))]
  
  # convert date to readable type
  data$date <- as.Date(data$date, origin = "1899-12-30")
  
  # create a variable to indicate which group (first cohort or second) based on date
  data[,first_group := (as.numeric(as.Date(data$date, origin = "1899-12-30") < "2021-03-26"))]
  
  return(data)
}
```

3. Apply functions to data
```{r}
treatment_initial <- clean_initial_data(treatment_initial, treatment = TRUE)
control_initial <- clean_initial_data(control_initial, treatment = FALSE)
treatment_final <- clean_final_data(treatment_final, treatment = TRUE)
control_final <- clean_final_data(control_final, treatment = FALSE)
```

```{r}
head(treatment_initial)
head(treatment_final)
head(control_initial)
head(control_final)
```

### Note we don't want to do this for the whole analysis since we need to use error bounds
4. Deal with attrition simply first 
```{r}
# getting rid of rows in final that don't exist in the initial (calling these faulty responses)
# joining initial and final datasets for both treatment and control groups

treatment_final <- treatment_final[ treatment_final$first_name %in% treatment_initial$first_name, ]
control_final <- control_final[ control_final$first_name %in% control_initial$first_name, ]
treatment <- merge(treatment_initial, treatment_final[,c('first_name','screen_time_avg_final')], by.x = "first_name", by.y = "first_name", all.x = TRUE, all.y = FALSE)
control <- merge(control_initial, control_final[,c('first_name','screen_time_avg_final')], by.x = "first_name", by.y = "first_name", all.x = TRUE, all.y = FALSE)

```

```{r}
head(treatment)
head(control)
```

5. Set up treatment and control group
```{r}
# replacing NA with zero for groups
treatment[treatment == 0] <- NA
control[control == 0] <- NA

# creating treatment column
treatment$treatment <- 1
control$treatment <- 0

# binding treatment and control data into one dataframe
data <- rbind(treatment,control, fill=TRUE)
```

```{r}
head(data)
```

6. Plot people who did not upload either screen time
```{r}
# drop people who have NA values for both screen_time_avg_final and screen_time_avg_initial
# issue with qualtrics for not getting their data for some reason
data <- data[!with(data,is.na(screen_time_avg_initial)& is.na(screen_time_avg_final)),]
```


```{r}
ggplot(data, aes(`screen_time_avg_initial`, fill = factor(treatment))) + geom_histogram(alpha = 0.2) + labs(title="Baseline Screen Time Averages")
```

```{r}
ggplot(data, aes(`screen_time_avg_final`, fill = factor(treatment))) + geom_histogram(alpha = 0.2) + labs(title="Final Screen Time Averages")
```

```{r}
data[is.na(data$screen_time_avg_initial) & data$treatment == 1]
```


```{r}
# replace na values in baseline (screen_time_avg_initial) with average of that column
# this is okay because we want an average baseline of where people are
# we don't want to do this with screen_time_avg_final because of attrition (we want to know which people didn't come back)
# we do this separately for treatment and control group
data$screen_time_avg_initial[is.na(data$screen_time_avg_initial) & data$treatment == 1] <- mean(treatment$screen_time_avg_initial,na.rm=TRUE)

data$screen_time_avg_initial[is.na(data$screen_time_avg_initial) & data$treatment == 0] <- mean(control$screen_time_avg_initial,na.rm=TRUE)

# getting the difference between final and initial screen times
data[, diff := screen_time_avg_final - screen_time_avg_initial]
```


```{r}
# compare individuals initial and final averages
ggplot(data, aes(`diff`, fill = factor(treatment))) + geom_histogram(alpha = 0.2) + labs(title="Screen Time Average Difference")
```
7. Estimate ITT and Cace ignoring attrition

```{r}
data[, greyscale_binary := ifelse(greyscale =='Yes', 1, 0)]
data[is.na(greyscale_binary), greyscale_binary:=0]
```


```{r}
simple_itt <- data[, lm(screen_time_avg_final ~ treatment + screen_time_avg_initial + country)]
simple_itt$vcovCL_val <- vcovCL(simple_itt)
itt_test <- coeftest(x = simple_itt, level = 0.95, vcov. = simple_itt$vcovCL_val)
itt_test

itt_d <- data[, lm(greyscale_binary ~ treatment)]
itt_d

cace <- coef(simple_itt)[2]/coef(itt_d)[2]
cace


cace2 <- coeftest(simple_itt,vcovHC(simple_itt))/coeftest(itt_d,vcovHC(itt_d))

```
```{r}

idx <- sample.int(nrow(data), 10)

data[idx,]
```











